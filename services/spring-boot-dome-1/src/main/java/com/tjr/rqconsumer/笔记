部署：
使用远程IP：
添加用户并设置密码:rabbitmqctl add_user  admin 123456
添加权限（使admin用户对虚拟主机“/” 具有所有权限）: rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
修改用户角色（加入administrator用户组）： rabbitmqctl set_user_tags admin administrator
就可以通过http://ip:15672 使用admin 123456 进行登陆了


前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：

routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”
binding key与routing key一样也是句点号“. ”分隔的字符串
binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）


 一、简介
         介绍RabbitMQ首先需要知道MQ是什么，MQ是 message queue 的简称，是应用程序和应用程序之间通信的方法。

         RabbitMQ是一个由erlang语言编写的、开源的、在AMQP基础上完整的、可复用的企业消息系统。支持多种语言，包括java、Python、ruby、PHP、C/C++等。

         AMQP：advanced message queuing protocol ，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息并不受客户端/中间件不同产品、不同开发语言等条件的限制。

 二、RabbitMQ五种消息发送模式
         RabbitMQ包括五种队列模式，简单队列、工作队列、发布/订阅、路由、主题、rpc等。

 1、简单队列
 简单队列
         1、生产者将消息发送到队列，消费者从队列获取消息。

         2、一个队列对应一个消费者。

 2、工作队列
 工作队列
         1、一个生产者，多个消费者。

         2、一个消息发送到队列时，只能被一个消费者获取。

         3、多个消费者并行处理消息，提升消息处理速度。

         注意:channel.basicQos(1)表示同一时刻只发送一条消息给消费者。

 3、发布/订阅模式(Publish/Subcribe)
 发布/订阅模式
         将消息发送到交换机，队列从交换机获取消息，队列需要绑定到交换机。

         1、一个生产者，多个消费者。

         2、每一个消费者都有自己的一个队列。

         3、生产者没有将消息直接发送到队列，而是发送到交换机。

         4、每一个队列都要绑定到交换机。

         5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的。

         6、交换机类型为“fanout”。

         注意：交换机本身没有存储消息的能力，消息只能存储到队列中。

 4、路由模式（Routing）
 路由模式
         路由模式是发布/订阅模式的一种特殊情况。

         1、路由模式的交换机类型为“direct”。

         2、绑定队列到交换机时指定 key，即路由键，一个队列可以指定多个路由键。

         3、生产者发送消息时指定路由键，这时，消息只会发送到绑定的key的对应队列中。

 4、主题模式（Topic）
 主题模式
         将路由键和某模式进行匹配。此时，队列需要绑定到一个模式上。符号“#”匹配一个或多个词，“*”匹配不多不少一个词。

         绑定队列到交换机指定key时，进行通配符模式匹配。

 三、RabbitMQ的其他特性
 1、消息确认机制
         生产者发送消息到RabbitMQ服务器，消费者从RabbitMQ服务器获取消息，服务端如何知道消息被消费者正常消费了呢？这就要说消息确认机制，RabbitMQ有两种消息确认机制。

         模式1：自动确认

         只要消息从队列中获取，无论消费者获取到消息后是否成功消费消息，服务端都认为消息成功被消费。

         模式2：手动确认

         消费者从队列获取消息后，服务器会将消息标记为不可用状态，等待消费者的反馈。如果消费者一直没有反馈，那么该消息将一直处于不可用状态。api:channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);

 2、持久化交换机和队列
         持久化：将交换机或队列数据保存到磁盘，服务器宕机或者重启之后数据依然存在。

         非持久化：将交换机或队列数据保存到磁盘到内存，服务器宕机或者重启之后数据会丢失。

         持久化性能要低于持久化，是否开启持久化取决于业务需求。

  